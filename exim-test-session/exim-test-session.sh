#!/bin/bash
#
# This script simulates an SMTP session from a remote host using 'exim -bhc'.
# It's purpose is similar to that provided by the exim_checkaccess tool
# distributed with Exim.
#
# Usage: Run without any arguments to see usage
#
# For reference: SMTP protocol RFC - http://tools.ietf.org/html/rfc5321
#
# Copyright (c) 2011 Lance Lovette. All rights reserved.
# Licensed under the BSD License.
# See the file LICENSE.txt for the full license text.
#
# Available from https://github.com/lovette/exim-tools

CMDPATH=$(readlink -f "$0")
CMDNAME=$(basename "$CMDPATH")
CMDDIR=$(dirname "$CMDPATH")
CMDARGS=$@

EXIMTOOL_VER="1.0.0"
EXIMBIN=/usr/sbin/exim
DEBUGOUTPUT=0
TESTEXIMDIRECT=0

##########################################################################
# Functions

# Print version and exit
function version()
{
	echo "exim-test-session $EXIMTOOL_VER"
	echo
	echo "Copyright (C) 2011 Lance Lovette"
	echo "Licensed under the BSD License."
	echo "See the distribution file LICENSE.txt for the full license text."
	echo
	echo "Written by Lance Lovette <https://github.com/lovette>"

	exit 0
}

# Print usage and exit
function usage()
{
	echo "Simulate delivery from HOSTIP with message from SENDER to RECIPIENT."
	echo
	echo "Usage: exim-test-session [-h | --help | -V | --version]"
	echo "   or: exim-test-session [OPTION]... HOSTIP SENDER RECIPIENT [HELO|-] [DATAFILE|-]"
	echo
	echo "Options:"
	echo "  -e             Test directly with 'exim -bhc' (does not test DATA command)"
	echo "  -h, --help     Show this help and exit"
	echo "  -v             Show debug information generated by exim"
	echo "  -V, --version  Print version and exit"
	echo
	echo "  HOSTIP     IP address of remote host"
	echo "  SENDER     Email address of sender; specify '-' to simulate"
	echo "             a bounce message with an empty sender"
	echo "  RECIPIENT  Email address of recipient"
	echo "  HELO       HELO/EHLO text to use instead of HOSTIP; '-' if default"
	echo "  DATAFILE   Path of file to use as content of DATA command; '-' if none"
	echo
	echo "Report bugs to <https://github.com/lovette/exim-tools/issues>"

	exit 0
}

##########################################################################
# Main

# Check for usage longopts
case "$1" in
	"--help"    ) usage;;
	"--version" ) version;;
esac

# Parse command line options
while getopts "ehvV" opt
do
	case $opt in
	e  ) TESTEXIMDIRECT=1;;
	h  ) usage;;
	v  ) DEBUGOUTPUT=1;;
	V  ) version;;
	\? ) echo "Try '$CMDNAME --help' for more information."; exit 1;;
	esac
done
    
shift $(($OPTIND - 1))
HOSTIP=$1
SENDER=$2
RECIPIENT=$3
HELO=$4
DATAFILE=$5

# If data file is specified, convert to a full path
[ "$DATAFILE" = "-" ] && DATAFILE=""
[ -n "$DATAFILE" ] && DATAFILE=$(readlink -f "$DATAFILE")

if [ -z "$HOSTIP" ] || [ -z "$SENDER" ] || [ -z "$RECIPIENT" ]; then
	echo "$CMDNAME: missing option -- HOSTIP, SENDER and RECIPIENT must be specified"
	echo "Try '$CMDNAME --help' for more information."
	exit 1
fi

if [[ ! "$HOSTIP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
	echo "HOSTIP must be an IP address"
	exit 1
fi
if [ "$SENDER" != "-" ] && [[ ! "$SENDER" =~ ^.+@.+$ ]]; then
	echo "SENDER must be an email address"
	exit 1
fi
if [[ ! "$RECIPIENT" =~ ^.+@.+$ ]]; then
	echo "RECIPIENT must be an email address"
	exit 1
fi

if [ -n "$DATAFILE" ]; then
	[ ! -f "$DATAFILE" ] && echo "$DATAFILE: data file does not exist" && exit 1
	[ ! -r "$DATAFILE" ] && echo "$DATAFILE: data file read permission denied" && exit 1
fi

[ -z "$HELO" ] || [ "$HELO" = "-" ] && HELO="$HOSTIP"

# Simulate bounce message
[ "$SENDER" = "-" ] && SENDER=""

if [ -z "$DATAFILE" ]; then
	echo "$HOSTIP [$HELO] <$SENDER> to <$RECIPIENT> D="
else
	echo "$HOSTIP [$HELO] <$SENDER> to <$RECIPIENT> D="$(basename "$DATAFILE")
fi

#######################################################################
#
# This section executes TESTEXIMDIRECT where we run exim directly
# The DATA command is not tested here because we don't know if we
# even get that far without a 5xx reply. (This applies to the other
# commands too, but best practice ACL don't fail until the RCPT.)
#
#######################################################################

if [ $TESTEXIMDIRECT -eq 1 ]; then
	(
	echo -n -e "HELO $HELO\r\n"
	echo -n -e "MAIL FROM:<$SENDER>\r\n"
	echo -n -e "RCPT TO:<$RECIPIENT>\r\n"
	echo -n -e "QUIT\r\n"
	) | $EXIMBIN -bhc "$HOSTIP"

	exit 0
fi

#######################################################################
#
# The rest of this script executes the default mode, where we
# control exim via pipes so we can monitor the session and reply codes
#
#######################################################################

# stripcr(text)
# Strip the CR line ending from text
# Result is saved in $lastline
stripcr()
{
	local text=$1
	lastline=${text//$'\r'/}
}

# is_smtp_reply(text)
# Returns success if reply is the last line of an SMTP reply
# If so, reply code is saved in $lastreplycode
is_smtp_reply()
{
	local reply=$1
	[[ "$reply" =~ "^([[:digit:]]{3})[[:space:]]" ]] && lastreplycode=${BASH_REMATCH[1]} && return 0
	return 1
}

# is_smtp_success()
# Returns success if $lastreplycode is 2xx
is_smtp_success()
{
	[[ "$lastreplycode" =~ "^[23]" ]] && return 0
	return 1
}

# readsmtpreply()
# Read all reply lines for an SMTP command
# Last reply line is saved in $lastline
# Reply code is saved in $lastreplycode
readsmtpreply()
{
	while :; do
		read lastline<&$EXIMSTDOUT_FD
		stripcr "$lastline"
		echo "$lastline" >> $STDOUTPATH
		is_smtp_reply "$lastline" && break
	done
}

# smtpcommand(cmd, capturecmd)
# Send an SMTP command
# Returns success if reply code is 2xx
# Command is optionally saved in $lastcmd
# Reply code is optionally saved in $lastcmdreplycode
# Last reply line is saved in $lastline
smtpcommand()
{
	local cmd=$1
	local capturecmd=$2

	[ $capturecmd -eq 1 ] && [[ "$cmd" =~ "^([[:alpha:]]+)" ]] && lastcmd=${BASH_REMATCH[1]}

	echo -n -e "$cmd\r\n" >&$EXIMSTDIN_FD

	readsmtpreply

	[ $capturecmd -eq 1 ] && lastcmdreplycode=$lastreplycode

	is_smtp_success && return 0

	return 1
}

# smtpdatacommand(path)
# Send an SMTP DATA command with data
# Returns success if reply code is 2xx
# Last reply line is saved in $lastline
smtpdatacommand()
{
	local datafile=$1

	if ! smtpcommand "DATA" 1; then
		return 1
	fi

	cat $datafile >&$EXIMSTDIN_FD

	smtpcommand "." 0

	# For capture last command as DATA with reply code from "."
	lastcmd="DATA"
	lastcmdreplycode=$lastreplycode

	is_smtp_success && return 0

	return 1
}

# clearstderr()
# Copies exim stderr output to our stderr file
# Returns success if stderr has text
clearstderr()
{
	local stderrhastext=0

	while read -u $EXIMSTDERR_FD -t 1 lastline
	do
		stripcr "$lastline"
		echo "$lastline" >> $STDERRPATH
		stderrhastext=1
	done

	[ $stderrhastext -eq 1 ] && return 0

	return 1
}

# Color values are listed terminfo man page
TTYRED=$(tput bold;tput setaf 1) # fg=red
TTYBLUE=$(tput bold;tput setaf 4;tput setab 7) # bg=white, fg=blue
TTYYELLOW=$(tput bold;tput setaf 6) # fg=yellow
TTYRESET=$(tput sgr0)

PATHSPECBASENAME=$(basename "$CMDPATH" ".sh")
STDOUTPATHSPEC="$PATHSPECBASENAME-stdout.XXXXXX"
STDERRPATHSPEC="$PATHSPECBASENAME-stderr.XXXXXX"

EXIMPIPEPATHSPEC="/tmp/$PATHSPECBASENAME-$$-XXX"
EXIMSTDINPATH="${EXIMPIPEPATHSPEC/XXX/stdin}"
EXIMSTDOUTPATH="${EXIMPIPEPATHSPEC/XXX/stdout}"
EXIMSTDERRPATH="${EXIMPIPEPATHSPEC/XXX/stderr}"

# These are the file descriptors we attach to the pipes
EXIMSTDIN_FD=3
EXIMSTDOUT_FD=4
EXIMSTDERR_FD=5

lastline=""
lastreplycode=""
lastcmd=""
lastcmdreplycode=""

# Create the pipes
for pipepath in $EXIMSTDINPATH $EXIMSTDOUTPATH $EXIMSTDERRPATH
do
	mkfifo $pipepath || exit 1
done

# Create temp files
STDOUTPATH=$(mktemp -t "$STDOUTPATHSPEC") || exit 1
STDERRPATH=$(mktemp -t "$STDERRPATHSPEC") || exit 1

# Delete temp files and pipes when script exits
trap "/bin/rm -f $EXIMSTDINPATH $EXIMSTDOUTPATH $EXIMSTDERRPATH $STDOUTPATH $STDERRPATH" EXIT

# Execute exim, redirect stdin/out/err to our pipes
/usr/sbin/exim -bhc $HOSTIP 0<$EXIMSTDINPATH 1>$EXIMSTDOUTPATH 2>$EXIMSTDERRPATH &
EXIMPID=$!

# Open the pipes; read/write prevents blocking
eval "exec $EXIMSTDOUT_FD<>$EXIMSTDOUTPATH"
eval "exec $EXIMSTDIN_FD>$EXIMSTDINPATH"
eval "exec $EXIMSTDERR_FD<>$EXIMSTDERRPATH"

# We can't test if exim exited immediately with an error, so we
# read stdout looking for the SMTP reply to then connect while
# also checking stderr when there is no reply or a timeout while
# reading from stdout. The first one without output wins.
while :; do
	while read -u $EXIMSTDOUT_FD -t 10 lastline
	do
		stripcr "$lastline"
		echo "$lastline" >> $STDOUTPATH
		is_smtp_reply "$lastline" && break
	done

	is_smtp_reply "$lastline" && break

	clearstderr && break
done

# If loop didn't break with an SMTP reply we assume
# that exim failed and stderr has the reason why
if ! is_smtp_reply "$lastline"; then
	clearstderr
	cat $STDERRPATH
	exit 1
fi

# Can only continue with session if each reply code is 2xx
if is_smtp_success; then
	if smtpcommand "HELO $HELO" 1; then
		if smtpcommand "MAIL FROM:<$SENDER>" 1; then
			if smtpcommand "RCPT TO:<$RECIPIENT>" 1; then
				if [ -r "$DATAFILE" ]; then
					smtpdatacommand "$DATAFILE"
				fi	
			fi
		fi
	fi

	smtpcommand "QUIT" 0
fi

# Read remaining text from exim stderr
clearstderr

# Close pipes
eval "exec $EXIMSTDOUT_FD<&-"
eval "exec $EXIMSTDIN_FD>&-"
eval "exec $EXIMSTDERR_FD<&-"

if [ $DEBUGOUTPUT -eq 1 ]; then
	echo "#######################################################################"
	sed "s/^/# /" $STDOUTPATH
	echo "#"
	sed "s/^/# /" $STDERRPATH
	echo "#######################################################################"
fi

# Output relevent stdout and stderr with color
egrep -v "^(>>>|\*\*\*\*|$)" "$STDOUTPATH" | sed -r "s/^(.*)$/$TTYBLUE\1$TTYRESET/"
egrep -v "^(>>>|PDKIM|$)" "$STDERRPATH" | sed -r "s/^(.*)$/$TTYRED\1$TTYRESET/"

# Print the line following each line that has "check add_header"
if grep -q "check add_header" "$STDERRPATH"; then
(
	awk "/check add_header/{n=1;next}n{print;n--}" "$STDERRPATH" | \
		sed -r "s/^[^=]+= (.+)$/\1/" | \
		sed -r "s/^(.*)$/${TTYYELLOW}HEADER: \1${TTYRESET}/"
)
fi

# Last line of output is final verdict
case "$lastcmdreplycode" in
	2*) echo "Accept";;
	4*) echo "Defer/$lastcmd";;
	5*) echo "Reject/$lastcmd";;
	* ) echo "Unexpected/$lastcmd";;
esac

exit 0
